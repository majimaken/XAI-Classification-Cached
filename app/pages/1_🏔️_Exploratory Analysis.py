# Bank Marketing XAI App

# Load Libraries
import streamlit as st 
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from ydata_profiling import ProfileReport
from streamlit_pandas_profiling import st_profile_report

from CachedFunctions import load_data, generate_profile_report, prepare_data, cached_xgb_model, predict_with_cached_model

# Disable Warnings
st.set_option('deprecation.showPyplotGlobalUse', False)

# Cache: Load data
df = load_data()

# Cache: Split and preprocess data
X_train, X_test, y_train, y_test = prepare_data(df)

# --------------------------------------------------------------

# Define app layout
# st.set_page_config(page_title='Exploratory Analysis', page_icon='üèîÔ∏è')
st.title('Exploratory Analysis of a Portugese Bank Marketing Dataset')

st.markdown("""
The Bank Marketing Data Set from UCI is a collection of information that helps us understand 
how a Portuguese bank marketed term deposits to potential customers. The data set consists of 45211 observations
containing different pieces of information about each customer, such as age, job, and education level. 
The outcome of the marketing campaign (predictor) is either successful or unsuccessful. 

This information can help us learn more about customer behavior, preferences, and patterns, 
which is useful for understanding customer behavior better and optimizing business strategies. 
""")

st.header("Overview of Data Set")
# Show Data Frame
st.dataframe(data = df)




st.header("Variables")
st.markdown("""
The following list describes the columns of the data set. While the first 16 are used as features, 
the last binary columns is whether the marketing campaign was successful or not.


1.  age:            age of person 
    - numeric
2.  job:           type of job 
    - categorical: ('admin.','blue-collar','entrepreneur','housemaid','management','retired','self-employed','services','student','technician','unemployed','unknown')
3.  marital:        marital status 
    - categorical: ('divorced','married','single','unknown'; note: 'divorced' means divorced or widowed)
4.  education:
    - categorical: ('basic.4y','basic.6y','basic.9y','high.school','illiterate','professional.course','university.degree','unknown')
5.  default: has credit in default? 
    - categorical: ('no','yes','unknown')
6.  balance: net asset value of person
    - numeric
7.  housing:        has housing loan? 
    - categorical: ('no','yes','unknown')
8.  loan: has personal loan? 
    - categorical: ('no','yes','unknown')
9.  contact: contact communication type 
    - categorical: ('cellular','telephone')
10.  month: last contact month of year 
    - categorical: ('jan', 'feb', 'mar', ..., 'nov', 'dec')
11. day_of_week: last contact day of the week 
    - categorical: ('mon','tue','wed','thu','fri')
12. duration: last contact duration, in seconds 
    - numeric 
13. campaign: number of contacts performed during this campaign and for this client 
    - numeric
14. pdays: number of days that passed by after the client was last contacted from a previous campaign 
    - numeric (-1 means client was not previously contacted)
15. previous: number of contacts performed before this campaign and for this client 
    - numeric
16. poutcome: outcome of the previous marketing campaign 
    - categorical: ('failure','nonexistent','success')
17. y (output variable): has the client subscribed a term deposit? 
    - binary: ('yes','no')
""")




st.header("Diving into Univariate Analysis")
st.markdown("""
This report is generated by the Pandas Profiling library and helps to conduct univariate exploratory data analysis
interactively. Feel free to select a column of interest.
""")
pr = generate_profile_report(df)
st_profile_report(pr)
plt.rcdefaults()
# pr = ProfileReport(df, 
                   # explorative = True,
                   # minimal = True,
                   # )
# st_profile_report(pr)




st.header("Checking Balance of Predictor")
st.markdown("""
One of the main challenges when working with classification models is the fact that the predictor of most data sets are imbalanced.
Unsurprisingly, this phenomenon is found in this data set as well. Approximately 13.6\% are successful observations.
""")
st.write(df["y"].value_counts())

# Create the plot using seaborn
plt.figure(figsize=(10,5))
sns.countplot(data=df, x="y")
plt.title("Absolute Frequency of Successful / Unsuccessful Campaigns")
plt.xlabel("y")
plt.ylabel("Count")
st.pyplot()
plt.rcdefaults()





st.header("Correlation Matrix")
st.markdown("""
The matrix shows the correlation of -1 to 1 between two columns. A value of 1 indicates a perfect positive correlation, a value of -1 
indicates a perfect negative correlation, and a value of 0 indicates no correlation. This helps to identify relationships
between variables. 

The color indicates that the correlation values scatter around zero for most of the variables. The variables pdays and previous
seem to almost have perfect correlation. Checking the Pandas Profiling report of these variables, it gets clear that this results
from the fact that most values are in 'neutral' position: 
- pdays = -1 (never previously contacted)
- previous = 0 (never previously contacted)

The general rule is that correlation and causality require discussion in most cases. In our case, 
the very high correlation can be well explained by the fact that it contains the same information. 
""")
plt.figure(figsize=(15,6))
sns.heatmap(df.corr(method = "spearman"), 
            annot=True, 
            cmap = "YlGnBu") #, cmap = "YlGnBu")
plt.title("Correlation Matrix", fontsize = 24)
plt.show()
st.pyplot()
plt.rcdefaults()




